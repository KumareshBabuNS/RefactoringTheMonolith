= A Tour of the Refactoring
:compat-mode:

== Step One: Independent Deployability

There's no real hope of having any sort of success with microservices as long as we're in the state where the same exact codebase must be deployed to run the website and to support managing individual stores. The eventual microservices we build will likely look very different in each context. So our first step is to create two independently deployable monoliths, each supporting a `common` shared library. The scope of the shared library gives us a real picture of just how tightly coupled the site and store code really are.

So in this stage we:

* Create a Gradle subproject structure: `common`, `store`, `site`.
* Refactor `build.gradle` to manage three subprojects, and we add `settings.gradle`.
* Parcel code out into the various subprojects.
* Fix compile errors and failing tests.

== Step Two: Finish an Existing Feature

We actually stopped work in progress when we completed Step One. A team has been laboring to finish up the order management screen for the stores, but has been unable to deliver due to churn on the website. Now that the applications are independently deployable, the store team can complete that UI feature and deploy it without waiting on the site team.

So in this stage we:

* Add a `StoreService` method, `orderDetails`.
* Add a `StoreController` method, `orderDetails`.
* Add a UI template, `orderDetails.html`.

== Step Three: Decouple the Contract between Site and Store

It was really easy to finish up that order details feature on the Store application. Unfortunately, the ease is deceptive. It was predicated on the fact that we are maintaining exactly the same DB schema, JPA domain model, and `OrderRepository` bewteen the two applications, all of this residing in the `common` project.

If you think about the responsibilities of the two applications, they're quite different:

* The Site application is charged with managing all of the various menu options and price combinations, as well as the customer address. It needs to have the full data model with all of its reference data to do this work.
* The Store application is charged with telling the stores what pizzas to prepare. We'll assume in this example that the store employees won't be editing these orders, just updating their status. So we don't need the full data model with all of its reference data. A denormalized representation of the exact order details will suffice!

So, we can break the contract by changing the messaging contract to only transmit the denormalized representation as JSON. This should eliminate the Store's dependency on the full JPA model and DB schema, and allow us to more fully decouple the applications.

So in this stage we:

* Implement a denormalized representation of the domain model as `OrderMessage`, `PizzaMessage`, etc.
* Implement `OrderTransformer` to convert the JPA model into the integration contract model.
* Introduce Spring Integration on both sides of the contract to facilitate the transformation and serialization of the model, as well as the AMQP orchestration.
* Eliminate the `common` project by inlining the JPA model and Spring Data repositories into the `site` project.
* Implement a lightweight JPA domain model in the `store` project.
* Convert the `store` UI to use the new lightweight domain model.

== Step Four: Implement Order Tracking Updates as Microservices
